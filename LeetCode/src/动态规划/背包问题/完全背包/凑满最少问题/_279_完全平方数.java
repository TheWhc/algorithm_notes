package 动态规划.背包问题.完全背包.凑满最少问题;

import java.util.Arrays;

/**
 * @ClassName: _279_完全平方数
 * @Author: whc
 * @Date: 2021/06/28/13:37
 */
public class _279_完全平方数 {

	// 完全背包 + 凑满问题 + 凑满最少问题

	/**
	 * 思路: 完全背包问题
	 *
	 * 如何转化为背包问题?
	 * 因为求的是凑成完全平方数的问题,所以凑成目标数当作背包容量,而凑成的完全平方数字看成物品,无限使用
	 *
	 * 1. 确定dp数组以及下标含义
	 * dp[j]: 表示凑成和为j的完全平方数的最少数量dp[j]
	 *
	 * 2. 确定递推公式
	 * dp[j] = Math.min(dp[j], dp[j-i*i] + 1)
	 *
	 * if(j >= i * i) {
	 *     dp[j] = Math.min(dp[j], dp[j-i*i] + 1)
	 * }
	 * 背包j的取值范围为[0,n]
	 * 物品i的取值范围为[1, i*i<=n]
	 *
	 * 3. 初始化
	 * dp[0] = 0
	 * 其余都初始化为最大值,防止被覆盖
	 *
	 * 4. 确定遍历顺序
	 * 先遍历物品,再遍历背包容量(正序遍历,物品可以重复放入)
	 * 或者先遍历背包容量,再遍历物品都可以
	 *
	 * 5. 举例推导dp数组
	 * 输入: n = 5
	 * 所以物品i的取值范围为[1,2]
	 * i * i <= 5
	 *
	 *  背包容量 0 1 2 3 4 5
	 * 物品0    0 1 2 3 4 5
	 * 物品1    0 1 2 3 1 2
	 *
	 */
	public int numSquares(int n) {

		int[] dp = new int[n+1];

		// 防止被覆盖
		Arrays.fill(dp, Integer.MAX_VALUE);
		// 凑成0,最少数量一定为0
		dp[0] = 0;

		// 外层遍历物品,即完全平方数
		for (int i = 1; i * i <= n; i++) {
			// 内层遍历背包容量, 即目标数n
			// 正序遍历,因为是凑满问题
			for (int j = i * i; j <= n; j++) {
				// 这里不用考虑dp[j - i * i] + 1 溢出的问题, 因为dp数组中的每个数一定会被凑满,不像零钱兑换那样,可能会出现无法凑满问题
				dp[j] = Math.min(dp[j], dp[j - i * i] + 1);
			}
		}

		return dp[n];
	}

}
