package 动态规划.背包问题.完全背包.凑满组合问题;

/**
 * @ClassName: _518_零钱兑换II
 * @Author: whc
 * @Date: 2021/06/28/10:48
 */
public class _518_零钱兑换II {

	// 完全背包 + 凑满背包问题 + 组合数,求凑满背包的个数

	/**
	 * 思路: 完全背包
	 * 1. 确定dp数组以及下标含义
	 * dp[j]: 凑成总金额为j的货币组合数为dp[j]
	 *
	 * 2. 确定递推公式
	 * dp[j](考虑coins[i]的组合总和),就是所有的dp[j-coins[i]]相加
	 *
	 * dp[j] += dp[j-coins[i]]
	 *
	 * 3. 初始化
	 * dp[0] = 1是一切递推的基础
	 *
	 * 4. 确定遍历顺序
	 * 外层遍历物品,内层遍历背包容量(正序遍历)
	 *
	 * 能否先遍历背包容量(正序遍历),再遍历物品?
	 * 答案是不行的,因为本题是求组合问题,不是求排列问题,排列问题才需要考虑元素之间的顺序问题
	 *
	 * 比如先遍历物品,再遍历背包容量,假设coins[0]=1,coins[1]=5
	 * 得到的方法数量只有{1,5},不会出现{5,1}情况
	 *
	 * 但是如果先遍历背包容量,再遍历物品,假设coins[0]=1,coins[1]=5
	 * 得到的方法数量既{1,5},也有{5,1}情况
	 *
	 * 5. 举例推导dp数组
	 *  amount = 5, coins = [1, 2, 5]
	 * 背包容量  0 1 2 3 4 5
	 * 物品0    1 1 1 1 1 1
	 * 物品1    1 1 2 2 3 3
	 * 物品2    1 1 2 2 3 4
	 */
	public int change(int amount, int[] coins) {
		int[] dp = new int[amount+1];

		dp[0] = 1;

		for (int i = 0; i < coins.length; i++) {
			for (int j = coins[i]; j <= amount; j++) {
				dp[j] += dp[j-coins[i]];
			}
		}

		return dp[amount];
	}
}
